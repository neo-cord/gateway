// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@neocord/utils
//   ../ws
//   ../zlib-sync
//   ../zlib
//   ../events

import type { Collection, Emitter } from "@neocord/utils";
import type { Inflate } from "zlib-sync";
import type { Unzip } from "zlib";
import type { EventEmitter } from "events";

export class CustomError {
  /**
   * @param name The name of the custom error.
   * @param message The error message.
   */
  constructor(name: string, message: string);
}

export class Shard extends Emitter {
  /**
   * The ID of this shard.
   * @type {number}
   */
  readonly id: number;
  /**
   * This shard's heartbeat handler.
   * @type {Heartbeat}
   */
  readonly heartbeat: Heartbeat;
  /**
   * This shard's session handler.
   * @type {Session}
   */
  readonly session: Session;
  /**
   * The status of this shard.
   * @type {Status}
   */
  status: Status;
  /**
   * When this shard connected to the gateway.
   * @type {number}
   */
  connectedAt: number;
  /**
   * Whether or not this shard is managed by the internal sharding manager.
   * @type {boolean}
   */
  managed: boolean;
  /**
   * Guilds that are expected to be received.
   * @type {?Set<string>}
   */
  expectingGuilds?: Set<string>;

  /**
   * @param {ShardManager} manager The ISM instance.
   * @param {number} id The ID of this shard.
   */
  constructor(manager: ShardManager, id: number);

  /**
   * The shard manager.
   * @type {ShardManager}
   */
  get manager(): ShardManager;

  /**
   * The current sequence.
   * @type {number}
   */
  get sequence(): number;

  /**
   * The sequence when the socket closed.
   * @type {number}
   */
  get closingSequence(): number;

  /**
   * The latency of this shard.
   * @type {number}
   */
  get latency(): number;

  /**
   * Whether or not this shard is connected.
   * @type {boolean}
   */
  get connected(): boolean;

  /**
   * Send a new payload to the gateway.
   * @param {Payload} data The payload to send.
   * @param {boolean} [prioritized] Whether or not to prioritize this payload.
   */
  send(data: Payload, prioritized?: boolean): void;

  /**
   * Destroys the websocket connection.
   * @param {DestroyOptions} options
   */
  destroy(options?: DestroyOptions): void;

  /**
   * Connects to the discord gateway.
   */
  connect(): void;
}

export interface DestroyOptions {
  code?: number;
  reset?: boolean;
  emit?: boolean;
  log?: boolean;
}

/**
 * Handles internalized bot sharding.
 */
export class ShardManager extends Emitter {
  /**
   * All shards currently being managed by the ISM.
   */
  readonly shards: Collection<number, Shard>;
  /**
   * The compression to use.
   */
  compression: CompressionType | false;
  /**
   * Whether or not the ISM is ready.
   */
  ready: boolean;
  /**
   * The type of serialization.
   */
  useEtf: boolean;
  /**
   * The options provided to this ISM instance.
   */
  options: Required<ShardManagerOptions>;
  /**
   * Whether or not this internal sharding manager is destroyed.
   */
  destroyed: boolean;
  /**
   * Whether or not this manager is reconnecting.
   */
  reconnecting: boolean;
  /**
   * The gateway address.
   */
  gatewayUrl: string;

  /**
   * Creates a new ShardManager.
   * @param options
   */
  constructor(options?: ShardManagerOptions);

  /**
   * The average latency across all shards.
   */
  get latency(): number;

  /**
   * The bot token.
   */
  get token(): string;
  /**
   * Set the token to use.
   * @param token The discord bot token.
   */
  set token(token: string);

  /**
   * Used for debugging the shard manager.
   */
  on(event: SMEvent.Debug, listener: (message: string) => void): this;
  /**
   * Emitted when this manager becomes invalidated.
   */
  on(event: SMEvent.Invalidated, listener: () => void): this;
  /**
   * Emitted when a shard receives a packet from discord.
   */
  on(event: SMEvent.RawPacket, listener: (pk: Payload, shard: Shard) => void): this;
  /**
   * Emitted when all shards become ready.
   */
  on(event: SMEvent.Ready, listener: () => void): this;
  /**
   * Emitted when the shard has disconnected from the gateway.
   */
  on(event: SMEvent.ShardDisconnect, listener: (shard: Shard, event: import("ws").CloseEvent) => void): this;
  /**
   * Emitted when the shard encounters an error.
   */
  on(event: SMEvent.ShardError, listener: (shard: Shard, event: any) => void): this;
  /**
   * Emitted when the shard has become ready.
   */
  on(event: SMEvent.ShardReady, listener: (shard: Shard, guild?: Set<string>) => void): this;
  /**
   * Emitted when the shard is reconnecting.
   */
  on(event: SMEvent.ShardReconnecting, listener: (shard: Shard) => void): this;

  /**
   * Destroys this manager.
   */
  destroy(): void;

  /**
   * Connects all shards.
   */
  connect(): Promise<void>;
}

export interface ShardManagerOptions {
  shards?: number | number[] | "auto";
  shardCount?: number | null;
  /**
   * The type of zlib compression to use, if you even want it.
   */
  compression?: CompressionType | boolean;
  /**
   * Whether or not to use etf encoding. Must have "erlpack" installed.
   */
  useEtf?: boolean;
  /**
   * The intents to use.
   */
  intents?: number;
  /**
   * Set a custom gateway url. Defaults to "auto".
   */
  url?: "auto" | string;
  /**
   * The gateway version to use.
   */
  version?: number;
  /**
   * The device properties.
   */
  properties?: {
    $device: string;
    $browser: string;
    $os: string;
  };
}

export interface SessionInfo {
  url: string;
  shards: number;
  session_start_limit: SessionStartLimit;
}

export interface SessionStartLimit {
  total: number;
  remaining: number;
  reset_after: number;
}

export enum GatewayOpCode {
  Dispatch = 0,
  Heartbeat = 1,
  Identify = 2,
  PresenceUpdate = 3,
  VoiceStateUpdate = 4,
  Resume = 6,
  Reconnect = 7,
  RequestGuildMembers = 8,
  InvalidSession = 9,
  Hello = 10,
  HeartbeatAck = 11
}

export enum GatewayEvent {
  Ready = "READY",
  Resumed = "RESUMED",
  GuildCreate = "GUILD_CREATE",
  GuildDelete = "GUILD_DELETE",
  GuildUpdate = "GUILD_UPDATE",
  InviteCreate = "INVITE_CREATE",
  InviteDelete = "INVITE_DELETE",
  GuildMemberAdd = "GUILD_MEMBER_ADD",
  GuildMemberRemove = "GUILD_MEMBER_REMOVE",
  GuildMemberUpdate = "GUILD_MEMBER_UPDATE",
  GuildMembersChunk = "GUILD_MEMBERS_CHUNK",
  GuildIntegrationsUpdate = "GUILD_INTEGRATIONS_UPDATE",
  GuildRoleCreate = "GUILD_ROLE_CREATE",
  GuildRoleDelete = "GUILD_ROLE_DELETE",
  GuildRoleUpdate = "GUILD_ROLE_UPDATE",
  GuildBanAdd = "GUILD_BAN_ADD",
  GuildBanRemove = "GUILD_BAN_REMOVE",
  GuildEmojisUpdate = "GUILD_EMOJIS_UPDATE",
  ChannelCreate = "CHANNEL_CREATE",
  ChannelDelete = "CHANNEL_DELETE",
  ChannelUpdate = "CHANNEL_UPDATE",
  ChannelPinsUpdate = "CHANNEL_PINS_UPDATE",
  MessageCreate = "MESSAGE_CREATE",
  MessageDelete = "MESSAGE_DELETE",
  MessageUpdate = "MESSAGE_UPDATE",
  MessageDeleteBulk = "MESSAGE_DELETE_BULK",
  MessageReactionAdd = "MESSAGE_REACTION_ADD",
  MessageReactionRemove = "MESSAGE_REACTION_REMOVE",
  MessageReactionRemoveAll = "MESSAGE_REACTION_REMOVE_ALL",
  MessageReactionRemoveEmoji = "MESSAGE_REACTION_REMOVE_EMOJI",
  UserUpdate = "USER_UPDATE",
  PresenceUpdate = "PRESENCE_UPDATE",
  TypingStart = "TYPING_START",
  VoiceStateUpdate = "VOICE_STATE_UPDATE",
  VoiceServerUpdate = "VOICE_SERVER_UPDATE",
  WebhooksUpdate = "WEBHOOKS_UPDATE"
}

export enum GatewayCloseCode {
  UnknownError = 4000,
  UnknownOpCode = 4001,
  DecodeError = 4002,
  NotAuthenticated = 4003,
  AuthenticationFailed = 4004,
  AlreadyAuthenticated = 4005,
  InvalidSeq = 4007,
  RateLimited = 4008,
  SessionTimedOut = 4009,
  InvalidShard = 4010,
  ShardingRequired = 4011,
  InvalidAPIVersion = 4012,
  InvalidIntents = 4013,
  DisallowedIntents = 4014
}

export enum Status {
  Connected = 0,
  Idle = 1,
  Ready = 2,
  Resuming = 3,
  Identifying = 4,
  Reconnecting = 5,
  Nearly = 6,
  Disconnected = 7,
  Connecting = 8,
  WaitingForGuilds = 9
}

export enum ShardEvent {
  Error = "error",
  Close = "close",
  Ready = "ready",
  Resumed = "resumed",
  InvalidSession = "invalidSession",
  Destroyed = "destroyed",
  FullReady = "fullReady"
}

export enum SMEvent {
  Ready = "ready",
  ShardError = "shardError",
  ShardReady = "shardReady",
  RawPacket = "raw",
  ShardDisconnect = "shardDisconnected",
  ShardReconnecting = "shardReconnecting",
  Invalidated = "invalidated",
  Debug = "debug"
}

export interface Payload<D = unknown> {
  op: GatewayOpCode;
  t?: GatewayEvent | null;
  d?: D;
  s?: number | null;
}

export const API = "https://discord.com/api/v8";
export const USER_AGENT = "NeoCord (v1 https://github.com/neo-cord)";
export const DEFAULTS: ShardManagerOptions;

export class ZlibSync extends Compression {
  /**
   * The zlib inflate instance.
   * @type {Zlib.Inflate}
   * @private
   */
  protected _zlib: Inflate;

  /**
   * Adds data to the zlib inflate.
   * @param {Compressible} data The data to compress.
   */
  add(data: Compressible): void;

  /**
   * Instantiates the zlib inflate.
   * @protected
   */
  protected init(): void;
}

export class Zlib extends Compression {
  /**
   * The unzip instance.
   * @type {Unzip}
   * @private
   */
  protected _zlib: Unzip;

  /**
   * Adds data to the zlib unzip.
   * @param {Compressible} data The data to compress.
   */
  add(data: Compressible): void;

  /**
   * Instantiates the unzip instance.
   * @protected
   */
  protected init(): void;
}

/**
 * Used for decompressing data sent by the discord gateway.
 */
export abstract class Compression extends EventEmitter {
  protected constructor();

  /**
   * Returns a new compression instance.
   * @param {CompressionType} type The type of compression to use, only "zlib" and "zlib-sync" are supported.
   * @returns {Compression}
   */
  static create(type: CompressionType): Compression;

  /**
   * Emitted when decompressed data is available.
   */
  on(event: "data", listener: (data: Buffer) => void): this;

  /**
   * Emitted when the compression handler runs into an error.
   */
  on(event: "error", listener: (data: Error) => void): this;

  /**
   * Used for debugging the compression handler.
   */
  on(event: "debug", listener: (message: string) => void): this;

  /**
   * Adds compressed data to the compression handler.
   * @param {Compressible} data The data to compress.
   */
  abstract add(data: Compressible): void;

  /**
   * Initializes the compression handler.
   * @protected
   */
  protected abstract init(): void;
}

export type CompressionType = "zlib" | "zlib-sync" | "pako";
export type Compressible = string | ArrayBuffer | Buffer | Buffer[];

export class Session {
  /**
   * The id of this session.
   * @type {string}
   */
  id?: string;

  /**
   * @param {Shard} shard The shard.
   */
  constructor(shard: Shard);

  /**
   * The sharding manager.
   */
  get manager(): ShardManager;

  /**
   * Resets the session.
   */
  reset(): void;

  /**
   * Sets a timeout for the HELLO op.
   */
  waitForHello(): void;

  /**
   * Clears the HELLO timeout and identifies a new session.
   */
  hello(): void;

  /**
   * Resumes or created a new session.
   */
  identify(): void;

  /**
   * Identify a new session.
   */
  new(): void;

  /**
   * Resumes the current session.
   */
  resume(): void;
}

export class Heartbeat {
  /**
   * Whether or not our last heartbeat was acknowledged.
   * @type {boolean}
   */
  acked: boolean;
  /**
   * When we last sent a heartbeat.
   * @type {number}
   */
  last: number;
  /**
   * The heartbeat interval.
   * @type {number}
   */
  interval?: number;
  /**
   * The heartbeat latency.
   * @type {number}
   */
  latency: number;

  /**
   * @param {Shard} shard The shard.
   */
  constructor(shard: Shard);

  /**
   * Sets the heartbeat interval.
   * @param ms
   */
  set heartbeatInterval(ms: number);

  /**
   * Resets this heartbeat.
   */
  reset(): void;

  /**
   * Called whenever the gateway sends a HeartbeatAck op.
   */
  ack(): void;

  /**
   * Sends a heartbeat to the gateway.
   * @param {string} reason The heartbeat reason.
   * @param {boolean} [ignore] The shard statuses to ignore.
   */
  new(reason: string, ignore?: boolean): void;
}

/**
 * Serialization handler for the JSON format. Uses the builtin JSON.parse and stringify methods.
 */
export class Json extends Serialization {
  /**
   * Encodes a payload into a json string.
   * @param {Payload} payload The payload to encode.
   * @returns {string}
   */
  encode(payload: Payload): string;

  /**
   * Decodes a decompressed websocket packet.
   * @param {RawData} raw The decompressed websocket packet.
   * @returns {Payload}
   */
  decode(raw: RawData): Payload;
}

export class EtfJS extends Serialization {
  /**
   * Encodes a payload into the etf format.
   * @param {Payload} payload The payload to encode.
   * @returns {Uint8Array}
   */
  encode(payload: Payload): Uint8Array;

  /**
   * Decodes a decompressed websocket packet into a json payload.
   * @param {RawData} raw Decompressed websocket packet.
   * @returns {Payload}
   */
  decode(raw: RawData): Payload;
}

export abstract class Serialization {
  /**
   * Returns a new serialization handler.
   * @param type The type of serialization provider.
   */
  static create(type: SerializationType): Serialization;

  /**
   * Serializes a payload for use with WebSocket#send
   * @param payload The gateway payload that will be encoded.
   */
  abstract encode(payload: Payload): Buffer | Uint8Array | string;

  /**
   * Deserializes a WebSocket packet to a JSON Payload.
   * @param raw The received and decompressed websocket packet.
   */
  abstract decode(raw: RawData): Payload;
}

export type SerializationType = "json" | "etf";
export type RawData = string | Buffer | Buffer[] | ArrayBuffer;

